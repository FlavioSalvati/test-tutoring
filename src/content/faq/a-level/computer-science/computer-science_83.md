---
title: "How is a breadth-first search implemented in a graph?"
summary: "A breadth-first search explores a graph by utilizing a queue to visit each vertex's neighbors before advancing to the next level, ensuring systematic exploration of all connected nodes."
author: "Prof. John Matthews"
degree: "PhD in Economics, London School of Economics"
tutor_type: "A-Level Economics Tutor"
date: 2024-07-02
---

A breadth-first search (BFS) in a graph is conducted using a queue to systematically visit and explore the neighbors of each vertex before progressing to the next level of vertices.

BFS prioritizes breadth over depth in its search strategy. This means that all vertices at the current level are explored before moving on to the vertices at the next level. The algorithm begins at a root node (or any arbitrary vertex in the graph, often referred to as the "search key") and investigates the neighboring nodes at the current depth before advancing to nodes at the subsequent depth level.

To implement BFS, a queue data structure is utilized. The algorithm initiates by enqueuing the starting vertex and marking it as visited. It then enters a loop where it dequeues a vertex for examination. If the dequeued vertex is the goal, the algorithm terminates. If not, the algorithm enqueues all unvisited neighbors of that vertex and marks them as visited. This process continues until all vertices have been explored or the goal is reached.

The pseudocode for the BFS algorithm is as follows:

1. Create an empty queue and enqueue the starting vertex.
2. Mark the starting vertex as visited.
3. While the queue is not empty, repeat the following steps:
   a. Dequeue a vertex from the queue, denoting it as $V$.
   b. For each unvisited neighbor of $V$, enqueue the neighbor and mark it as visited.

The time complexity of BFS is $O(V + E)$, where $V$ represents the number of vertices and $E$ denotes the number of edges in the graph. This complexity arises because, in the worst case, each vertex and edge will be examined. BFS is particularly useful for finding the shortest path in a graph in terms of the number of edges and for determining whether a graph is connected. Additionally, it plays a crucial role in various graph theory algorithms, including Dijkstra's algorithm for identifying the shortest path in weighted graphs.
    