---
title: "What's the difference between an abstract data type and a concrete data type?"
summary: "An abstract data type (ADT) defines a data type conceptually, while a concrete data type provides a specific implementation of a data type."
author: "Dr. Isabella Harris"
degree: "PhD in Computational Theory, University of Sheffield"
tutor_type: "A-Level Computer Science Tutor"
date: 2024-01-16
---

An abstract data type (ADT) provides a conceptual framework for a data type, while a concrete data type offers a specific implementation of that data type.

An abstract data type, commonly abbreviated as ADT, serves as a high-level description of a collection of data along with the operations that can be performed on this data. The term 'abstract' implies that it does not define the underlying storage mechanisms or the algorithms for executing these operations. Instead, it outlines the operations to be performed without detailing their implementation. Essentially, an ADT acts as a blueprint that can be realized in various ways, with different implementations potentially varying in efficiency. Examples of widely recognized ADTs include lists, stacks, queues, and trees.

In contrast, a concrete data type—often referred to as a data structure—is a specific implementation of an ADT. It delineates the precise storage method and the algorithms that will be used for the operations, which is why it is termed 'concrete.' This type represents the actual data within a computer program or a physical device and encompasses both the data collection and the associated operations. Common examples of concrete data types include arrays, linked lists, binary trees, and hash tables.

Understanding the distinction between abstract and concrete data types is essential in computer science. ADTs enable programmers to conceptualize data and operations at a high level, freeing them from the complexities of low-level implementation details. This abstraction facilitates the design and reasoning about software systems. Conversely, concrete data types empower programmers to translate these high-level designs into actual code. Grasping the difference between these two concepts can significantly enhance your ability to write efficient and maintainable code.
    